# Задача для Target AI компании
## Основное описание
Необходимо реализовать консольное приложение, которое работает на основе **LLM - инструментов** и может выполнить под собой различные подзадачи.

## Шаги:

### 1 Шаг. 
#### Реализация консольного приложения, которое работает на основе **LLM - инструмента**

Реализован первый проект под названием **Console.App**. Он включает в себя реализацию консольного приложения. 

Консольное приложение работает с **LLM - инструментом**. 

За основу взят **Ollama** и его версия **lama3** так как он является бесплатной и его проще всего подключить через _Docker-Compose.yml_ файл.

#### Нюансы:
+ При отправке своего промта можно долго ожидать ответа.

### Шаг 2:
#### Реализация WebSocketServer.

Реализован второй проект с названием **ReadySolution**, который решает подзадачу. 
Решение задачи и весь код который там есть был предложен **LLM - инструментом**, а также с моими мелкими доработками

#### Промты, которые я давал LLM - Инструменту:
1. Напиши мне класс WebSocketServer, который принимает в конструкторе HttpListner. Этот класс имеет метод StartAsync(string adress). Этот метод должен запускать WebSocket сервер на адресе, который был передан в параметре. Сервер должен работать в цикле while пока значение у CancellationToken.IsCancellationRequested = false. Внутри цикла мы получаем данные из внешних клиентов, например от JS. Перед выполнением логики мы проверяем, является ли запрос WebSocket, если да, то мы устанавливаем соединение и асинхронно выполняем приватный метод HandleConnectionAsync(WebSocket webSocket, CancellationToken token).
Внутри приватного метода мы создаем массив байтов с размером в 1024 элемента.

2. Теперь изменим этот метод HandleConnectionAsync, добавив в него цикл while. Он будет работать пока Состояние WebSocket отрыто и не было запроса отмены token.IsCancellationRequested.
Внутри цикла мы получаем данные. Далее проверяем, если данные не пустые, то мы сохраняем данные в файл с разрешением .raw. Нам нужно создать еще один приватный метод в этом классе SaveDataToFile(), который принимает массив байтов и также данные в виде WebSocketreciveResult.

3. Теперь создадим класс SharedMemoryManager, предварително скачав nuget пакет SharedMemory. Этот класс реализует интерфейс IDisposible. У этого класса есть 2 метода: WriteAsync(byte[] data) и ReadAsync(int sizeForRead)
Также при инициализации класса нам необходимо создать SharedArray на основе byte. В методе WriteAsync мы будем записывать данные в SharedMemory данные из массива байтов, принимаемым в параметре метода.
Метод ReadAsync возвращает массив байтов. Мы берем данные из SharedMemory и записываем их в инициализированный массив байтов, который мы потом вернем.

4. Далее, реализуем метод SaveDataToFile. Мы просто должны записать данные в SharedMemory.WriteAsync.
Также потом прочитать данные из sharedMemory и записать данные в файл.

### Шаг 3:
После небольшого рефакторинга своего кода я получил конечный результат.

Данная программа может принимать любые аудио дорожки, переводить их в raw формат и сохранять в файлы типа raw.

## Важно

Необходимо перед работой поднять **docker-compose.yml** файл. После чего посмотреть, есть ли модели рядом с docker-compose файлом в одном месте, если нету, тогда прописать:
```
docker exec -it ollama-server ollama pull llama3
```
Как я уже и говорил, запросы могут выполняться медленно. Возможно это связано с интернет соединением.